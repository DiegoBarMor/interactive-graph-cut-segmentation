<!DOCTYPE html>
  <html>
    <head>
      <title>Interactive Graph Cut Image Segmentation</title>
      <link rel="stylesheet" type="text/css" href=style.css>
      <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
      <script type = "text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
      </script>
      <script type="text/javascript" async
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
      </script>
    </head>
    <body>
      <nav class="navbar">
        <div class="line">
          <a class="btn" href="#introduction">Introduction</a>
          <a class="btn" href="#theory">Theoretical Background</a>
          <a class="btn" href="#graph">Graph Preparation</a>
        </div>
        <div class="line">
          <a class="btn" href="#algorithm">Boykov-Kolmogorov Algorithm</a>
          <a class="btn" href="#implementation">Python Implementation</a>
          <a class="btn" href="#references">References</a>
        </div>
      </nav>

      <div class="contents">
        <h1>Interactive Graph Cut Image Segmentation</h1>

        <h2 id="introduction">Introduction</h2>
          Interactive image segmentation techniques are a promising alternative to fully automatic segmentation. They take a small human input as ground truth and then expand it via an algorithm to segment the image with (hopefully) more realistic and useful results. <br><br>

          The method described in <a href="#ref1">[1]</a> and <a href="#ref2">[2]</a> was implemented in Python and can be found <a href="https://github.com/DiegoBarqueroMorera/interactive-graph-cut-segmentation" target="_blank">here</a>. The goal of this method is to segment a 2D image into two parts (binary segmentation): <b>object</b> and <b>background</b>. A user provides a set of pixels that are certain to be part of the object, and another set of pixels certain to be part of the background. Both sets are denominated <b>seeds</b> for object and background respectively.
          <br><br>

          Taking into account both sets of seeds, the image is first represented as a directed graph. Then, the image is segmented by finding the optimal <i>cut</i> of the edges of the graph, by exploiting the <i>max-flow min-cut</i> theorem. In the next sections, a brief introduction of these concepts is presented, as well as the details of the algorithm and the Python implementation.

        <h2 id="theory">Theoretical Background</h2>
          <h3>Graphs</h3>
            A <b>graph</b> $G = \langle V, E \rangle$ is defined as a set of <b>nodes</b> $V$ and a set of <b>edges</b> $E$. Each edge $e \in E$ connects a pair of nodes $p, q \in V$, and is represented as $e = (p, q)$. A graph is <b>undirected</b> if $$e = (p, q) = (q, p) \quad \forall e \in E; p, q \in V$$

            and <b>directed</b> if $$e = (p, q) \neq (q, p)$$

            Finally, in a <b>weighted</b> (or capacitated) graph, each edge $e \in E$ is assigned a weight (or <b>cost</b>) $w_e \in \mathbb{R}$. <br><br>

            An image can be represented as a graph by taking the intensity $Ip$ of each pixel $p$ and assigning it to a node in the subset $P \subset V$. The position information of the pixels is conserved by defining a subset of edges $E_n \subset E$ such that any pair of nodes $p, q \in V$ corresponding to neighbouring pixels in the image is connected by an edge $e_n = (p, q) \in E_n$. Depending on the application, the graph may be defined as undirected or directed; in the latter case, another edge is defined for each pair of pixels $e_n' = (q, p)$. The edges from $E_n$ are known as neighbouring or <b>non-terminal</b> edges. For this implementation, 4-connected pixels are considered as neighbours, although some adjustments can be done for using other criteria.

            <figure>
              <img src="report-figures/n_edges.png", alt="Non-terminal edges">
              <figcaption> Example of a 5x5 image (left) and its graph representation (right). Each node stores the original $Ip$ information and is connected to its neighbours by non-terminal edges. </figcaption>
            </figure>

            For this segmentation method, two special nodes are added: an "object" terminal called <b>source</b> ($S$) and a "background" terminal called <b>sink</b> ($T$). This means that $$V = P \cup \{S, T\}$$

            Furthermore, additional edges connect each node from $P$ to both $S$ and $T$, such that $$E_t = \bigcup_{p \in P} \{\{S,p\}, \{p,T\}\} \\ E = E_n \cup E_t$$

            Note that if directed edges are been employed, the order of the edges from $E_t$ matter.

            <figure>
              <img src="report-figures/n_t_edges.png", alt="Non-terminal and terminal edges">
              <figcaption> Example of a 5x5 image (left) and its graph representation (right). The graph is expanded by adding the terminal nodes $S$ and $T$, as well as the edges connecting them to all the nodes from $P$. </figcaption>
            </figure>

          <h3>Graph Cuts</h3>
            Given a set of nodes $A = \{a_1, \dots, a_n\}$, a <b>path</b> is a sequence of edges that allows to traverse from $a_1$ to $a_n$. A path that starts in the source and finished at the sink will be denominated here as $path_{St}$. A generic path can be defined as $$Path = \bigcup_i^{n-1} \{\{a_i, a_{i+1}\}\}$$

            A <b>cut</b> is a subset of edges $C \subset E$ such that in the graph $G' = (V, E \backslash C)$ there is no path between the terminal nodes $S$ and $T$. Alternatively, it can be seen as the graph being separated into two sub-graphs, where all the nodes from a given subgraph is only connected to the same terminal node $$G' = G_S \cup G_T \\
            G_S = \langle V_S, E_n' \bigcup_{p \in P_S} \{(S,p)\} \rangle \\
            G_T = \langle V_T, E_n' \bigcup_{p \in P_T} \{(p,T)\} \rangle $$

            Finally, the <b>cost</b> of the cut is defined as the sum of the weights of the edges it comprises $$|C| = \sum_{e \in C} w_e$$

            <figure>
              <img src="report-figures/cut.png", alt="Graph cut">
              <figcaption> Example of a 5x5 image (left) and its graph representation (right). The subset of edges $C$ is removed from the graph, removing all possible paths from $S$ to $T$. </figcaption>
            </figure>

          <h3>Graph Flow</h3>
            A weighted graph can be interpreted as a network of "pipes" described by its edges, where water can be imagined to flow in a given direction. For the specific graphs described before, the flow starts at the source node $S$, goes through the image nodes $P$ and end up in the sink node $T$ (hence the terminology used for the terminal nodes). <br><br>

            The weights of the edges can represent different concepts under this interpretation, depending on what is required:

            <ul>
              <li><b>Flow</b> ($flow \ge 0$): The amount of water currently pushed through an edge. This value remains constant</li>
              <li><b>Capacity</b> ($cap \ge 0$): How much water is supported by an edge</li>
              <li><b>Residual</b> capacity ($res \ge 0$): The capacity left after pushing a certain amount of flow through the edge, given by $res = cap - flow$</li>
            </ul>

            <p>
              Note the at any given moment the flow going through an edge can't exceed its capacity, so  $flow \le cap \implies res \ge 0$. In the specific case when $flow = edge \implies res = 0$, it is said that the edge is <b>saturated</b>, meaning that it is moving the maximum amount of water it can handle. Similarly, a <b>saturated path</b> is a path where one or more edges are saturated. For the purposes of this method, all edges composing a cut must be saturated.
            </p>
            
          <h3>Optimal Cut</h3>
            The idea of defining all of this concepts is to find a way to measure a given image segmentation. Such measure is to be optimized via an automatic algorithm, in order to choose the best image segmentation from the space of all possible segmentations. <br><br>

            Intuitively, a graph cut can be interpreted as the segmentation of the image represented by the graph. An optimal segmentation would be a cut $C$ such that the nodes from the subgraphs obtained, $N_S$ and $N_T$, correspond to pixels that most likely belong to the object and background respectively. This <b>optimal cut</b> corresponds to the cut with the lowest cost $|C|$, and is often obtained by minimizing an energy function of the general form $$E(L) = \sum_{p \in P}Rp(Lp) + \sum_{(p,q) \in E_n}Bp(p, q)$$

            where $L = \{L_p \in \{obj, bkg\} | p \in P\}$ is the binary labeling of the image, $Rp$ is a regional penalty function and $Bp$ a boundary penalty function. <br><br>

            As the names suggest, $Rp$ penalizes pixels according to the region they are associated with. Here, "region" refers to either the object or the background, so the penalty works by checking how probable is the pixel part of the object or background, given a prior intensity distribution obtained from the data. This prior is built from the seeds provided by the user. On the other hand, $Bp$ penalizes pixels according to their local interaction with neighbouring pixels, by comparing their $Ip$ values with some sort of metric. <br><br>

            For minimizing the energy and thus obtain the optimal cut, the <b>max-flow min-cut</b> theorem can be exploited. This theorem states that the maximum flow from $S$ to $T$ saturates a set of edges $C^*$ that correspond to the minimum cut, leaving behind two disjoint subgraphs $G_S$ and $G_T$. The objective of many graph based segmentation methods is to take advantage on this duality property and find the maximum flow of the system, which guarantees the minimum cut and the optimal segmentation given the inputs.

        <h2 id="graph">Graph Preparation</h2>
          After mapping the pixels of the image into the nodes and edges of a graph, assigning weights to the edges requires an energy function to be defined. For this implementation, the energy functions were inspired by <a href="#ref1">[1]</a>. Consider $Obj \in P$ the subset of pixels marked as a seed for object and $Bkg \in P$ the pixels marked as a seed for background. Then, the energy functions consist of
          $$
          Bp(p, q) = \exp(-\frac{(Ip - Iq)^2}{2 \sigma^2})\\
          Rp_{obj}(p) = -\ln(\Pr(Ip | Obj)) \\
          Rp_{bkg}(p) = -\ln(\Pr(Ip | Bkg))
          $$

          In this implementation, the probability of the intensity given a seed is dsecribed by the histogram of intensities for pixels in the given seed. Other approaches could also be considered, such as using the seeds to estimate the parameters of a Gaussian distribution. Furthermore, a constant $K$ is also defined as $$K = 1 + \max_{p \in P} \sum_{q : (p,q) \in E_n} Bp(p,q)$$

          The edges can then be assigned weights according to the following table (note that both $\sigma$ and $\lambda$ are parameters that need to be set by the user):

          <table class="tg">
          <thead>
            <tr>
              <th class="tg-nrix">edge type</th>
              <th class="tg-nrix">weight (cost)</th>
              <th class="tg-nrix">condition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="tg-nrix">$(p,q)$</td>
              <td class="tg-nrix">$Bp(p,q)$</td>
              <td class="tg-nrix">$(p,q) \in E_n$</td>
            </tr>
            <tr>
              <td class="tg-nrix" rowspan="3">$(S,p)$</td>
              <td class="tg-nrix">$\lambda Rp_{bkg}(p)$</td>
              <td class="tg-nrix">$p \in P, p \notin Obj \cup Bkg$</td>
            </tr>
            <tr>
              <td class="tg-nrix">$K$</td>
              <td class="tg-nrix">$p \in Obj$</td>
            </tr>
            <tr>
              <td class="tg-nrix">$0$</td>
              <td class="tg-nrix">$p \in Bkg$</td>
            </tr>
            <tr>
              <td class="tg-nrix" rowspan="3">$(p,T)$</td>
              <td class="tg-nrix">$\lambda Rp_{obj}(p)$</td>
              <td class="tg-nrix">$p \in P, p \notin Obj \cup Bkg$</td>
            </tr>
            <tr>
              <td class="tg-nrix">$0$</td>
              <td class="tg-nrix">$p \in Obj$</td>
            </tr>
            <tr>
              <td class="tg-nrix">$K$</td>
              <td class="tg-nrix">$p \in Bkg$</td>
            </tr>
          </tbody>
          </table>

          Taking into account that high cost values are better candidates to be in the minimal cut, it can be noted that $Bp$ returns higher values when $Ip$ and $Iq$ differ significantly, which is a natural way of predicting a border between neighbouring pixels. <br><br>

          Less intuitively, $Rp$ provides lower values when it is more probable that $Ip$ corresponds to the seed. This means $Rp$ is used to assign weights to edges connecting to the terminal of the <i>contrary</i> seed it represents. For example, if a pixel is very probable to be part of "obj", then it should be favourable to cut its edge to $T$  ("bkg"), and so on. <br><br>

          Pixels that are marked as seeds take this to the extreme, by assigning $0$ to their opposite seed, marking them as cut by default. On the contrary, a very high constant $K$ is assigned to the weight of their corresponding seed, making the cut unfeasible under all circumstances. This could also be adjusted to $K = \infty$ if desired.

        <h2 id="algorithm">Boykov-Kolmogorov Algorithm</h2>
          <p>
            Once the graph is initialized, different algorithms can be used to find the max-flow. For this implementation, an <i>augmenting path</i> based algorithm described in <a href="#ref2">[2]</a> was employed, which will continue to be described as the <b>BK algorithm</b>. 
          </p>
          <p>
            Traditionally, augmenting path algorithms iteratively look for the shortest paths from the source to the sink ($path_{ST}$), having to start the search process if time that all the paths of a given length are exhausted (i.e. they become saturated). The BK algorithm seeks to improve performance of other push-relabel methods by optimizing the step where $path_{ST}$ is searched, by reusing paths from previous iterations.
          </p>

          <p>
            The basic idea is to build two separate non-overlapping search trees, one starting from $S$ and the other from $T$. These trees are grown (via, for example, breadth first search), and whenever they touch, a $path_{ST}$ is found. Note that this path is not necessarily the shortest path possible. After using the $path_{ST}$, the trees are shortened in a particular way, so in next iterations the modified trees are taken as starting point and grown.
          </p>
          <h3>Overview</h3>
            At any given moment, two search trees occupy nodes from $P$: $S_t$ having as root the source and $T_t$ having as root the sink. The nodes not present in $S_t \cup T_t$ are said to be "free", and can be grouped as $F$. Therefore
            $$S_t \subset V, \quad T_t \subset V, \quad F \subset N, \quad S_t \cup T_t \cup F = V \\ S_t \cap T_t = T_t \cap F = F \cap S_t = \emptyset$$

            This algorithm is based on a directed graph, so order of edges does matter. For any given edge $E = (p,q)$ of a tree, a <b>parent-child</b> relationship can be defined according to the tree it belongs to. Furthermore, any edge covered by a search tree must be unsaturated.
            
            
            <table class="tg">
              <thead>
                <tr>
                  <th class="tg-nrix">tree</th>
                  <th class="tg-nrix">parent</th>
                  <th class="tg-nrix">child</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td class="tg-nrix">$S_t$</td>
                  <td class="tg-nrix">$p$</td>
                  <td class="tg-nrix">$q$</td>
                </tr>
                <tr>
                  <td class="tg-nrix">$T_t$</td>
                  <td class="tg-nrix">$q$</td>
                  <td class="tg-nrix">$p$</td>
                </tr>
              </tbody>
            </table>
            
            The nodes from either tree can be <b>active</b> or <b>passive</b>. The active nodes $A \subset N$ are the leaves of the tree, while passive nodes are internal. Active nodes $p \in A$ allow the tree to <b>grow</b> by recruiting new children $q$ such that $q \in F$ and $e = (p, q), w_e > 0$. During this process, a $path_{ST}$ is found when a leaf from $S_t$ tries to recruit a leaf from $T_t$ or viceversa. These concepts are schematized by <a href="#ref2">[2]</a> in the following way:

            <figure>
              <img id="fig_with_text" src="report-figures/bk_schema.png", alt="Schema for the BK algorithm">
            </figure>

            A final subset of nodes $O$ denominated <b>orphans</b> is also considered. The BK algorithm is started by <a href="#graph">representing the image as a graph</a>, then initializing the search related subsets as
            $$S_t = Obj, \quad T_t = Bkg, \quad A = Borders(S_t) \cup Borders(T_t), \quad O = \emptyset$$

            Some other terms are also defined, namely:
            <ul>
                <li>$TREE(p)$, a flag that stores whether a node is part of $S_t$, $T_t$ or $F$</li>
                <li>$PARENT(p)$, to refer to the parent of $p$ in $TREE(p)$</li>
                <li>$ORIGIN(p)$, which can be either $S$ or $T$ and requires a valid path between $p$ and its respective terminal, otherwise $ORIGIN(p) = \varnothing$</li>
                <li>$cap(p \to q)$, which refers to the residual capacity of the edge $(p, q)$ if $TREE(p) = S_t$ or $(q, p)$ if $TREE(p) = T_t$</li>
            </ul>

            After initialization, the algorithm iteratively repeats three stages: <b>Growth</b>, <b>Augmentation</b> and <b>Adoption</b>. Exiting from the loop is controlled by the result of the growth stage.

            <figure>
              <img id="fig_small" src="report-figures/borders.png", alt="Description of Borders()">
              <figcaption>Description of the $Borders$ function. This is a small addition to the original BK algorithm that optimizes the first iteration when large seeds are given.</figcaption>
            </figure>

          <h3>Growth</h3>
            This stage is summarized by <a href="#ref2">[2]</a> as: "search trees [$S_t$] and [$T_t$] grow until they touch giving a [$path_{ST}$]". This is the stage where active nodes try to recruit new free nodes, until all active nodes are depleted. It returns a $path_{st}$ if it finds one, otherwise the stage loop ends and $path_{st}$ is returned as $\emptyset$. This halts the BK algorithm main loop, indicating that the optimal cut was found.

            <figure>
              <img id="fig_with_text" src="report-figures/stage_grow.png", alt="Pseudocode for the growth stage">
              <figcaption>Pseudocode for the growth stage, as provided by <a href="#ref2">[2].</a></figcaption>
            </figure>

          <h3>Augmentation</h3>
            This stage is summarized by <a href="#ref2">[2]</a> as: "the found path is augmented, search tree(s) break into forest(s)". It takes as input the $path_{ST}$ found in the growth stage, and pushes the maximum amount of flow that path can handle. This means one or more edges in the path get saturated, making these edges invalid as a parent-child relationship. An affected child node becomes both an <b>orphan</b> and the root of a new subtree $O_t$ spanning the orphan's descendants. Futhermore, $ORIGIN(n) = \varnothing \quad \forall n \in O_t$.

            <figure>
              <img id = "fig_with_text" src="report-figures/stage_augment.png", alt="Pseudocode for the augmentation stage">
              <figcaption>Pseudocode for the augmentation stage, as provided by <a href="#ref2">[2].</a></figcaption>
            </figure>

          <h3>Adoption</h3>
            This stage is summarized by <a href="#ref2">[2]</a> as: "trees [$S_t$] and [$T_t$] are restored". This stage seeks to find a new valid parent $p$ for each orphan $o$. A valid parent should satisfy $TREE(p) = TREE(o), ORIGIN(p) = TREE(o)$ and the edge connecting them must satisfy $w_e > 0$. If a parent is found, the subtree $O_t$ is restored to the main tree and $ORIGIN(n) = TREE(p) \quad \forall n \in O_t$. If no parent is found, $TREE(o) := F$ and its children are declared as orphans. Furthermore, all neighbours $q$ of $o$ such that $TREE(q) = TREE(o)$ should become active. This procedure is repeated until no orphans are left.

            <figure>
              <img id = "fig_with_text" src="report-figures/stage_adopt.png", alt="Pseudocode for the adoption stage">
              <figcaption>Pseudocode for the adoption stage, as provided by <a href="#ref2">[2].</a></figcaption>
            </figure>

        <h2 id="#implementation">Python Implementation</h2>

          (...)

        <h2 id="references">References</h2>
          <ol>
            <li id="ref1">https://www.csd.uwo.ca/~yboykov/Papers/iccv01.pdf</li>
            <li id="ref2">https://www.csd.uwo.ca/~yboykov/Papers/pami04.pdf</li>
          </ol>

      </div>
    </body>
  </html>
